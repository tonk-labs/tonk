<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tonk Core WASM Example</title>
    <style>
      .output {
        font-family: monospace;
        background: #f8f8f8;
        padding: 10px;
        border: 1px solid #ccc;
        white-space: pre-wrap;
      }
    </style>
  </head>
  <body>
    <h1>Tonk Core WASM Example</h1>

    <div class="section">
      <h2>Sync Engine</h2>
      <button onclick="createEngine()">Create Sync Engine</button>
      <button onclick="connectWebSocket()">Connect to WebSocket</button>
      <input
        type="text"
        id="wsUrl"
        placeholder="ws://localhost:8081"
        value="ws://localhost:8081"
      />
      <div id="engineOutput" class="output"></div>
    </div>

    <div class="section">
      <h2>Virtual File System</h2>
      <input
        type="text"
        id="filePath"
        placeholder="Enter file path"
        value="/test/file.txt"
      />
      <input
        type="text"
        id="fileContent"
        placeholder="Enter file content"
        value="Hello from WASM!"
      />
      <br />
      <button onclick="createFile()">Create File</button>
      <button onclick="readFile()">Read File</button>
      <button onclick="deleteFile()">Delete File</button>
      <button onclick="listDirectory()">List Directory</button>
      <div id="vfsOutput" class="output"></div>
    </div>

    <div class="section">
      <h2>Bundle Operations</h2>
      <input
        type="text"
        id="bundleKey"
        placeholder="Enter key"
        value="test/data.json"
      />
      <input
        type="text"
        id="bundleValue"
        placeholder="Enter value"
        value='{"message": "Hello from bundle!"}'
      />
      <br />
      <button onclick="createBundle()">Create Bundle</button>
      <button onclick="putValue()">Put Value</button>
      <button onclick="getValue()">Get Value</button>
      <button onclick="listKeys()">List Keys</button>
      <div id="bundleOutput" class="output"></div>
    </div>

    <script type="module">
      import init, {
        create_sync_engine,
        create_bundle_from_bytes,
        WasmSyncEngine,
        WasmVfs,
        WasmBundle,
      } from '../../pkg-browser/tonk_core.js';

      let engine = null;
      let vfs = null;
      let bundle = null;

      // Initialize WASM module
      async function initWasm() {
        await init();
        log('engineOutput', 'WASM module initialized');
      }

      // Helper function to log output
      function log(elementId, message) {
        const output = document.getElementById(elementId);
        const timestamp = new Date().toLocaleTimeString();
        output.textContent = `[${timestamp}] ${message}\n${output.textContent}`;
      }

      // Sync Engine functions
      window.createEngine = async function () {
        try {
          console.log(`[CLIENT-${Math.random().toString(36).substr(2, 9)}] Creating sync engine...`);
          engine = await create_sync_engine();
          const peerId = await engine.getPeerId();
          log('engineOutput', `[CLIENT] Sync engine created with peer ID: ${peerId}`);

          // Get VFS instance
          vfs = await engine.getVfs();
          log('engineOutput', '[CLIENT] VFS instance obtained');
        } catch (err) {
          log('engineOutput', `[CLIENT] Error creating engine: ${err}`);
        }
      };

      window.connectWebSocket = async function () {
        if (!engine) {
          log('engineOutput', '[CLIENT] Please create engine first');
          return;
        }

        const url = document.getElementById('wsUrl').value;
        const clientId = Math.random().toString(36).substr(2, 9);
        try {
          console.log(`[CLIENT-${clientId}] Connecting to WebSocket: ${url}`);
          // Use the new method that adopts server's root document
          await engine.connectWebsocketWithServerRoot(url);
          log('engineOutput', `[CLIENT-${clientId}] Connected to WebSocket and adopted server root: ${url}`);
          
          // Get updated VFS instance after root adoption
          vfs = await engine.getVfs();
          log('engineOutput', `[CLIENT-${clientId}] VFS updated with server root document`);
        } catch (err) {
          log('engineOutput', `[CLIENT-${clientId}] Error connecting: ${err}`);
        }
      };

      // VFS functions
      window.createFile = async function () {
        if (!vfs) {
          log('vfsOutput', '[CLIENT] Please create engine first');
          return;
        }

        const path = document.getElementById('filePath').value;
        const content = document.getElementById('fileContent').value;
        const clientId = Math.random().toString(36).substr(2, 9);

        try {
          console.log(`[CLIENT-${clientId}] Creating file: ${path} with content: "${content}"`);
          await vfs.createFile(path, content);
          log('vfsOutput', `[CLIENT-${clientId}] File created: ${path}`);
        } catch (err) {
          log('vfsOutput', `[CLIENT-${clientId}] Error creating file: ${err}`);
        }
      };

      window.readFile = async function () {
        if (!vfs) {
          log('vfsOutput', 'Please create engine first');
          return;
        }

        const path = document.getElementById('filePath').value;

        try {
          const content = await vfs.readFile(path);
          log(
            'vfsOutput',
            `File content: ${content || '(empty or not found)'}`
          );
        } catch (err) {
          log('vfsOutput', `Error reading file: ${err}`);
        }
      };

      window.deleteFile = async function () {
        if (!vfs) {
          log('vfsOutput', 'Please create engine first');
          return;
        }

        const path = document.getElementById('filePath').value;

        try {
          const deleted = await vfs.deleteFile(path);
          log('vfsOutput', `File deleted: ${deleted}`);
        } catch (err) {
          log('vfsOutput', `Error deleting file: ${err}`);
        }
      };

      window.listDirectory = async function () {
        if (!vfs) {
          log('vfsOutput', '[CLIENT] Please create engine first');
          return;
        }

        const path = document.getElementById('filePath').value;
        const dirPath = path.substring(0, path.lastIndexOf('/')) || '/';
        const clientId = Math.random().toString(36).substr(2, 9);

        try {
          console.log(`[CLIENT-${clientId}] Listing directory: ${dirPath}`);
          const entries = await vfs.listDirectory(dirPath);
          log(
            'vfsOutput',
            `[CLIENT-${clientId}] Directory listing for ${dirPath}:\n${JSON.stringify(entries, null, 2)}`
          );
        } catch (err) {
          log('vfsOutput', `[CLIENT-${clientId}] Error listing directory: ${err}`);
        }
      };

      // Bundle functions
      window.createBundle = async function () {
        try {
          // Create an empty ZIP file structure for demo
          const encoder = new TextEncoder();
          const manifestContent = JSON.stringify({
            manifestVersion: 1,
            version: { major: 1, minor: 0 },
            root: 'main',
            entrypoints: [],
            networkUris: [],
          });

          // For demo purposes, we'll create a simple ZIP structure
          // In real usage, you would load an actual bundle file
          log(
            'bundleOutput',
            'Note: Bundle creation from scratch not implemented in this demo'
          );
          log('bundleOutput', 'Please load an existing bundle file');
        } catch (err) {
          log('bundleOutput', `Error creating bundle: ${err}`);
        }
      };

      window.putValue = async function () {
        if (!bundle) {
          log('bundleOutput', 'Please create or load a bundle first');
          return;
        }

        const key = document.getElementById('bundleKey').value;
        const value = document.getElementById('bundleValue').value;
        const encoder = new TextEncoder();
        const data = encoder.encode(value);

        try {
          await bundle.put(key, data);
          log('bundleOutput', `Value stored at key: ${key}`);
        } catch (err) {
          log('bundleOutput', `Error storing value: ${err}`);
        }
      };

      window.getValue = async function () {
        if (!bundle) {
          log('bundleOutput', 'Please create or load a bundle first');
          return;
        }

        const key = document.getElementById('bundleKey').value;

        try {
          const data = await bundle.get(key);
          if (data) {
            const decoder = new TextDecoder();
            const value = decoder.decode(data);
            log('bundleOutput', `Value at ${key}: ${value}`);
          } else {
            log('bundleOutput', `No value found at key: ${key}`);
          }
        } catch (err) {
          log('bundleOutput', `Error getting value: ${err}`);
        }
      };

      window.listKeys = async function () {
        if (!bundle) {
          log('bundleOutput', 'Please create or load a bundle first');
          return;
        }

        try {
          const keys = await bundle.listKeys();
          log('bundleOutput', `Bundle keys:\n${JSON.stringify(keys, null, 2)}`);
        } catch (err) {
          log('bundleOutput', `Error listing keys: ${err}`);
        }
      };

      // Initialize on page load
      initWasm().catch(console.error);
    </script>
  </body>
</html>
