use anyhow::Result;
use iroh::{Endpoint, NodeAddr, NodeId, SecretKey};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use tauri::{AppHandle, Emitter, Manager};
use tokio::sync::RwLock;
use tokio::task::JoinHandle;

use super::config::{ConfigManager, DiscoveryPreferences};
use super::connection::{ConnectionAttempt, ConnectionConfig, ConnectionManager};
use super::discovery::DiscoveryManager;
use super::mdns::{MdnsConfig, TonkServiceInfo};
use super::network::NetworkInterface;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AutomergeMessage {
    #[serde(rename = "type")]
    pub message_type: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub data: Option<Vec<u8>>,
    #[serde(rename = "senderId")]
    pub sender_id: Option<String>,
    #[serde(rename = "targetId")]
    pub target_id: Option<String>,
    #[serde(rename = "documentId")]
    pub document_id: Option<String>,
    #[serde(rename = "peerMetadata", skip_serializing_if = "Option::is_none")]
    pub peer_metadata: Option<serde_json::Value>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PeerInfo {
    pub peer_id: String,
    pub bundle_id: String,
    pub connected: bool,
}

pub struct P2PManager {
    endpoint: Option<Endpoint>,
    secret_key: SecretKey,
    peers: Arc<RwLock<HashMap<String, PeerInfo>>>,
    connections: Arc<RwLock<HashMap<String, iroh::endpoint::Connection>>>,
    bundle_id: Option<String>,
    node_id: Option<String>,
    port: u16,
    app_handle: AppHandle,
    discovery_manager: Option<DiscoveryManager>,
    connection_manager: Option<ConnectionManager>,
    config_manager: Option<ConfigManager>,
    accept_task: Option<JoinHandle<()>>,
}

impl P2PManager {
    pub fn new(app_handle: AppHandle) -> Self {
        // Create config path in app data directory
        let config_path = app_handle
            .path()
            .app_data_dir()
            .unwrap_or_else(|_| std::env::temp_dir())
            .join("tonk")
            .join("discovery_config.json");

        Self {
            endpoint: None,
            secret_key: SecretKey::from_bytes(&[0u8; 32]), // Will be replaced during initialization
            peers: Arc::new(RwLock::new(HashMap::new())),
            connections: Arc::new(RwLock::new(HashMap::new())),
            bundle_id: None,
            node_id: None,
            port: 0,
            app_handle,
            discovery_manager: None,
            connection_manager: None,
            config_manager: Some(ConfigManager::new(config_path)),
            accept_task: None,
        }
    }

    pub async fn initialize(&mut self) -> Result<()> {
        // Load configuration
        if let Some(config_manager) = &mut self.config_manager {
            config_manager.load().await.unwrap_or_else(|e| {
                eprintln!("Failed to load config, using defaults: {}", e);
            });
        }

        // Initialize Iroh endpoint with auto-generated secret key
        let endpoint = Endpoint::builder()
            .alpns(vec![b"tonk-sync".to_vec()]) // ALPN for Tonk sync protocol
            .bind()
            .await
            .map_err(|e| anyhow::anyhow!("Failed to bind Iroh endpoint: {}", e))?;

        // Update our secret key with the one generated by the endpoint
        self.secret_key = endpoint.secret_key().clone();

        // Get the node ID and actual listening port from the endpoint
        let node_id = endpoint.node_id().to_string();

        // Get the actual port the endpoint is listening on
        let local_addr = endpoint
            .bound_sockets()
            .into_iter()
            .next()
            .map(|socket| socket.port())
            .unwrap_or(0);

        self.node_id = Some(node_id.clone());
        self.port = local_addr;

        // Start accepting connections in the background
        let accept_task = self.start_accept_loop(endpoint.clone()).await;
        self.accept_task = Some(accept_task);

        self.endpoint = Some(endpoint);

        // Initialize connection manager with config
        let connection_config = if let Some(config_manager) = &self.config_manager {
            config_manager.to_connection_config()
        } else {
            ConnectionConfig::default()
        };

        let mut connection_manager =
            ConnectionManager::new(self.app_handle.clone(), connection_config);

        // Start the retry manager
        connection_manager.start_retry_manager().await?;
        self.connection_manager = Some(connection_manager);

        println!(
            "P2P Manager initialized successfully with node ID: {} on port: {}",
            node_id, self.port
        );

        // Emit ready event to frontend
        self.app_handle
            .emit(
                "iroh_ready",
                serde_json::json!({
                    "nodeId": node_id,
                    "port": self.port
                }),
            )
            .map_err(|e| anyhow::anyhow!("Failed to emit iroh_ready event: {}", e))?;

        Ok(())
    }

    pub async fn start_discovery(&mut self, bundle_id: String) -> Result<()> {
        if self.node_id.is_none() {
            return Err(anyhow::anyhow!("P2P Manager not initialized"));
        }

        self.bundle_id = Some(bundle_id.clone());

        // Create and start discovery manager
        let mut discovery_manager = DiscoveryManager::new(
            bundle_id.clone(),
            self.node_id.clone().unwrap(),
            self.port,
            self.app_handle.clone(),
        );

        // Start mDNS discovery
        discovery_manager.start_mdns_discovery().await?;

        // Start DHT discovery
        discovery_manager.start_dht_discovery().await?;

        self.discovery_manager = Some(discovery_manager);

        println!("Discovery started for bundle: {}", bundle_id);

        // Emit ready event to frontend
        self.app_handle
            .emit(
                "p2p_ready",
                serde_json::json!({
                    "bundleId": bundle_id,
                    "nodeId": self.node_id.clone().unwrap(),
                    "port": self.port
                }),
            )
            .map_err(|e| anyhow::anyhow!("Failed to emit p2p_ready event: {}", e))?;

        Ok(())
    }

    pub async fn connect_to_peer(&self, peer_id: String) -> Result<()> {
        println!("Attempting to connect to peer: {}", peer_id);

        // Track the connection attempt
        if let Some(connection_manager) = &self.connection_manager {
            connection_manager
                .track_connection_attempt(peer_id.clone())
                .await?;
        }

        let endpoint = self
            .endpoint
            .as_ref()
            .ok_or_else(|| anyhow::anyhow!("Endpoint not initialized"))?;

        // Parse the peer ID as a NodeId
        let node_id: NodeId = peer_id
            .parse()
            .map_err(|e| anyhow::anyhow!("Invalid peer ID format: {}", e))?;

        // Look up discovered peer information for addresses
        let direct_addresses = if let Some(discovery_manager) = &self.discovery_manager {
            let discovered_peers = discovery_manager.get_discovered_peers().await;
            let peer_info = discovered_peers.iter().find(|p| p.node_id == peer_id);

            if let Some(info) = peer_info {
                println!(
                    "Found discovered peer info: addresses={:?}, port={}",
                    info.addresses, info.port
                );

                // Convert IpAddr + port to SocketAddr for direct connections
                let socket_addrs: Vec<std::net::SocketAddr> = info
                    .addresses
                    .iter()
                    .map(|ip| std::net::SocketAddr::new(*ip, info.port))
                    .collect();

                println!("Using socket addresses for connection: {:?}", socket_addrs);
                socket_addrs
            } else {
                println!("No discovered peer info found for peer: {}", peer_id);
                Vec::new()
            }
        } else {
            println!("No discovery manager available");
            Vec::new()
        };

        // Create NodeAddr with discovered addresses if available
        let node_addr = NodeAddr::from_parts(
            node_id,
            None,             // No relay URL for now
            direct_addresses, // Use discovered addresses
        );

        match endpoint.connect(node_addr, b"tonk-sync").await {
            Ok(connection) => {
                // Store the connection
                {
                    let mut connections = self.connections.write().await;
                    connections.insert(peer_id.clone(), connection.clone());
                }

                // Update peer info
                {
                    let mut peers = self.peers.write().await;
                    peers.insert(
                        peer_id.clone(),
                        PeerInfo {
                            peer_id: peer_id.clone(),
                            bundle_id: self.bundle_id.clone().unwrap_or_default(),
                            connected: true,
                        },
                    );
                }

                // Mark connection as successful
                if let Some(connection_manager) = &self.connection_manager {
                    connection_manager.mark_connection_success(&peer_id).await?;
                }

                // Start message handling for this connection
                self.start_connection_handler(peer_id.clone(), connection)
                    .await;

                // Emit connection event to frontend
                self.app_handle
                    .emit(
                        "peer_connected",
                        serde_json::json!({
                            "peerId": peer_id,
                            "timestamp": chrono::Utc::now().to_rfc3339()
                        }),
                    )
                    .map_err(|e| anyhow::anyhow!("Failed to emit peer_connected event: {}", e))?;

                println!("Successfully connected to peer: {}", peer_id);
                Ok(())
            }
            Err(e) => {
                let reason = format!("Connection failed: {}", e);

                if let Some(connection_manager) = &self.connection_manager {
                    connection_manager
                        .mark_connection_failure(&peer_id, &reason)
                        .await?;
                }

                Err(anyhow::anyhow!(
                    "Failed to connect to peer {}: {}",
                    peer_id,
                    reason
                ))
            }
        }
    }

    pub async fn send_automerge_message(
        &self,
        target_id: String,
        message: AutomergeMessage,
    ) -> Result<()> {
        println!(
            "Sending message to peer: {} type: {}, documentId: {:?}",
            target_id, message.message_type, message.document_id
        );

        // Handle broadcast messages (like arrive)
        if target_id == "broadcast" || message.message_type == "arrive" {
            // Send to all connected peers
            let connections = self.connections.read().await;
            for (peer_id, conn) in connections.iter() {
                println!("Broadcasting message to peer: {}", peer_id);
                self.send_message_to_connection(conn.clone(), message.clone())
                    .await?;
            }
            return Ok(());
        }

        // Get the connection for this specific peer
        let connection = {
            let connections = self.connections.read().await;
            connections.get(&target_id).cloned()
        };

        if let Some(conn) = connection {
            self.send_message_to_connection(conn, message).await
        } else {
            Err(anyhow::anyhow!("No connection to peer: {}", target_id))
        }
    }

    async fn send_message_to_connection(
        &self,
        conn: iroh::endpoint::Connection,
        message: AutomergeMessage,
    ) -> Result<()> {
        // Open a new unidirectional stream for this message
        match conn.open_uni().await {
            Ok(mut send_stream) => {
                // Serialize the message as JSON
                let serialized = serde_json::to_vec(&message)
                    .map_err(|e| anyhow::anyhow!("Failed to serialize message: {}", e))?;

                // Send the message
                send_stream
                    .write_all(&serialized)
                    .await
                    .map_err(|e| anyhow::anyhow!("Failed to write message: {}", e))?;

                send_stream
                    .finish()
                    .map_err(|e| anyhow::anyhow!("Failed to finish stream: {}", e))?;

                println!("Message sent successfully, type: {}", message.message_type);
                Ok(())
            }
            Err(e) => Err(anyhow::anyhow!("Failed to open stream: {}", e)),
        }
    }

    pub async fn disconnect_all_peers(&self) -> Result<()> {
        println!("Disconnecting all peers");

        // Close all connections
        {
            let mut connections = self.connections.write().await;
            for (peer_id, connection) in connections.drain() {
                println!("Closing connection to peer: {}", peer_id);
                connection.close(0u32.into(), b"shutdown");
            }
        }

        // Clear peer list
        {
            let mut peers = self.peers.write().await;
            peers.clear();
        }

        self.app_handle
            .emit("all_peers_disconnected", serde_json::json!({}))
            .map_err(|e| anyhow::anyhow!("Failed to emit all_peers_disconnected event: {}", e))?;

        Ok(())
    }

    pub fn get_node_id(&self) -> Option<String> {
        self.node_id.clone()
    }

    pub async fn get_connected_peers(&self) -> Vec<PeerInfo> {
        let peers = self.peers.read().await;
        peers.values().filter(|p| p.connected).cloned().collect()
    }

    pub async fn get_discovered_peers(&self) -> Result<Vec<TonkServiceInfo>> {
        if let Some(discovery_manager) = &self.discovery_manager {
            Ok(discovery_manager.get_discovered_peers().await)
        } else {
            Ok(Vec::new())
        }
    }

    pub async fn configure_mdns(&mut self, config: MdnsConfig) -> Result<()> {
        if let Some(discovery_manager) = &self.discovery_manager {
            discovery_manager.update_mdns_config(config).await?;
        }
        Ok(())
    }

    pub async fn toggle_discovery(&mut self, enabled: bool) -> Result<()> {
        if let Some(discovery_manager) = &mut self.discovery_manager {
            discovery_manager.set_enabled(enabled);
            if enabled {
                discovery_manager.restart_discovery().await?;
            } else {
                discovery_manager.stop_mdns_discovery().await?;
            }
        }
        Ok(())
    }

    pub async fn restart_discovery(&mut self) -> Result<()> {
        if let Some(discovery_manager) = &mut self.discovery_manager {
            discovery_manager.restart_discovery().await?;
        }
        Ok(())
    }

    pub fn get_port(&self) -> u16 {
        self.port
    }

    pub fn get_bundle_id(&self) -> Option<String> {
        self.bundle_id.clone()
    }

    pub async fn get_connection_status(&self, peer_id: &str) -> Option<ConnectionAttempt> {
        if let Some(connection_manager) = &self.connection_manager {
            connection_manager.get_connection_status(peer_id).await
        } else {
            None
        }
    }

    pub async fn get_all_connection_attempts(&self) -> HashMap<String, ConnectionAttempt> {
        if let Some(connection_manager) = &self.connection_manager {
            connection_manager.get_all_connection_attempts().await
        } else {
            HashMap::new()
        }
    }

    pub async fn reset_connection_attempts(&self, peer_id: &str) -> Result<()> {
        if let Some(connection_manager) = &self.connection_manager {
            connection_manager
                .reset_connection_attempts(peer_id)
                .await?;
        }
        Ok(())
    }

    pub async fn configure_connections(&mut self, config: ConnectionConfig) -> Result<()> {
        if let Some(connection_manager) = &mut self.connection_manager {
            connection_manager.update_config(config);
        }
        Ok(())
    }

    pub async fn get_network_interfaces(
        &self,
    ) -> Option<std::collections::HashMap<String, NetworkInterface>> {
        if let Some(discovery_manager) = &self.discovery_manager {
            discovery_manager.get_network_interfaces().await
        } else {
            None
        }
    }

    pub async fn get_primary_interface(&self) -> Option<NetworkInterface> {
        if let Some(discovery_manager) = &self.discovery_manager {
            discovery_manager.get_primary_interface().await
        } else {
            None
        }
    }

    pub async fn has_network_connectivity(&self) -> bool {
        if let Some(discovery_manager) = &self.discovery_manager {
            discovery_manager.has_network_connectivity().await
        } else {
            false
        }
    }

    pub async fn refresh_network_info(&self) -> Result<()> {
        if let Some(discovery_manager) = &self.discovery_manager {
            discovery_manager.refresh_network_info().await?;
        }
        Ok(())
    }

    pub async fn get_discovery_preferences(&self) -> Option<DiscoveryPreferences> {
        if let Some(config_manager) = &self.config_manager {
            Some(config_manager.get_preferences().clone())
        } else {
            None
        }
    }

    pub async fn update_discovery_preferences(
        &mut self,
        preferences: DiscoveryPreferences,
    ) -> Result<Vec<String>> {
        if let Some(config_manager) = &mut self.config_manager {
            // Validate preferences first
            let temp_config = ConfigManager::new(std::path::PathBuf::new());
            let mut temp_config = temp_config;
            *temp_config.get_preferences_mut() = preferences.clone();
            let validation_errors = temp_config.validate_preferences();

            if !validation_errors.is_empty() {
                return Ok(validation_errors);
            }

            // Update config
            config_manager.update_preferences(preferences).await?;

            // Apply new configurations to running services
            self.apply_configuration_changes().await?;
        }
        Ok(vec![])
    }

    pub async fn reset_discovery_preferences(&mut self) -> Result<()> {
        if let Some(config_manager) = &mut self.config_manager {
            config_manager.reset_to_defaults();
            config_manager.save().await?;
            self.apply_configuration_changes().await?;
        }
        Ok(())
    }

    pub async fn export_discovery_config(&self) -> Result<Option<String>> {
        if let Some(config_manager) = &self.config_manager {
            Ok(Some(config_manager.export_config().await?))
        } else {
            Ok(None)
        }
    }

    pub async fn import_discovery_config(&mut self, config_json: &str) -> Result<Vec<String>> {
        if let Some(config_manager) = &mut self.config_manager {
            let validation_errors = config_manager.import_config(config_json).await?;
            if validation_errors.is_empty() {
                self.apply_configuration_changes().await?;
            }
            Ok(validation_errors)
        } else {
            Ok(vec!["Configuration manager not available".to_string()])
        }
    }

    async fn apply_configuration_changes(&mut self) -> Result<()> {
        if let Some(config_manager) = &self.config_manager {
            let _preferences = config_manager.get_preferences();

            // Update mDNS configuration
            if let Some(discovery_manager) = &self.discovery_manager {
                let mdns_config = config_manager.to_mdns_config();
                discovery_manager.update_mdns_config(mdns_config).await?;
            }

            // Update connection configuration
            if let Some(connection_manager) = &mut self.connection_manager {
                let connection_config = config_manager.to_connection_config();
                connection_manager.update_config(connection_config);
            }

            // If discovery is currently running, restart it to apply changes
            if self.discovery_manager.is_some() && self.bundle_id.is_some() {
                println!("Applying configuration changes by restarting discovery");
                self.restart_discovery().await?;
            }
        }
        Ok(())
    }

    async fn find_available_port() -> Result<u16> {
        use std::net::{SocketAddr, TcpListener};

        // Get port start from environment variable, default to 8000
        let port_start = std::env::var("P2P_PORT_START")
            .ok()
            .and_then(|s| s.parse::<u16>().ok())
            .unwrap_or(8000);

        // Try to bind to a port starting from the configured port
        for port in port_start..(port_start + 1000) {
            let addr: SocketAddr = format!("127.0.0.1:{}", port).parse()?;
            if TcpListener::bind(addr).is_ok() {
                return Ok(port);
            }
        }

        // Fallback: let the OS choose a port
        let listener = TcpListener::bind("127.0.0.1:0")?;
        let port = listener.local_addr()?.port();
        Ok(port)
    }

    async fn start_accept_loop(&self, endpoint: Endpoint) -> JoinHandle<()> {
        let app_handle = self.app_handle.clone();
        let peers = Arc::clone(&self.peers);
        let connections = Arc::clone(&self.connections);

        tokio::spawn(async move {
            println!("Starting accept loop for incoming connections");

            while let Some(incoming) = endpoint.accept().await {
                let app_handle = app_handle.clone();
                let peers = Arc::clone(&peers);
                let connections = Arc::clone(&connections);

                // Handle each incoming connection in a separate task
                tokio::spawn(async move {
                    match incoming.await {
                        Ok(connection) => {
                            let peer_id = match connection.remote_node_id() {
                                Ok(node_id) => node_id.to_string(),
                                Err(e) => {
                                    eprintln!("Failed to get remote node ID: {}", e);
                                    return;
                                }
                            };
                            println!("Accepted connection from peer: {}", peer_id);

                            // Store the connection
                            {
                                let mut conns = connections.write().await;
                                conns.insert(peer_id.clone(), connection.clone());
                            }

                            // Update peer info
                            {
                                let mut peer_list = peers.write().await;
                                peer_list.insert(
                                    peer_id.clone(),
                                    PeerInfo {
                                        peer_id: peer_id.clone(),
                                        bundle_id: String::new(), // Will be set during discovery
                                        connected: true,
                                    },
                                );
                            }

                            // Emit connection event
                            if let Err(e) = app_handle.emit(
                                "peer_connected",
                                serde_json::json!({
                                    "peerId": peer_id,
                                    "timestamp": chrono::Utc::now().to_rfc3339()
                                }),
                            ) {
                                eprintln!("Failed to emit peer_connected event: {}", e);
                            }

                            // Start handling messages from this connection
                            Self::handle_connection_messages(peer_id, connection, app_handle).await;
                        }
                        Err(e) => {
                            eprintln!("Failed to accept incoming connection: {}", e);
                        }
                    }
                });
            }

            println!("Accept loop ended");
        })
    }

    async fn start_connection_handler(
        &self,
        peer_id: String,
        connection: iroh::endpoint::Connection,
    ) {
        let app_handle = self.app_handle.clone();

        // Start handling messages from this connection
        tokio::spawn(async move {
            Self::handle_connection_messages(peer_id, connection, app_handle).await;
        });
    }

    async fn handle_connection_messages(
        peer_id: String,
        connection: iroh::endpoint::Connection,
        app_handle: AppHandle,
    ) {
        println!("Starting message handler for peer: {}", peer_id);

        loop {
            match connection.accept_uni().await {
                Ok(mut recv_stream) => {
                    // Handle this message stream
                    tokio::spawn({
                        let peer_id = peer_id.clone();
                        let app_handle = app_handle.clone();

                        async move {
                            match recv_stream.read_to_end(64 * 1024).await {
                                // 64KB max message size
                                Ok(data) => {
                                    // Try to deserialize the message
                                    match serde_json::from_slice::<AutomergeMessage>(&data) {
                                        Ok(message) => {
                                            println!("Received message from peer {}: type={}, data_len={}, documentId={:?}", 
                                                peer_id, message.message_type, 
                                                message.data.as_ref().map(|d| d.len()).unwrap_or(0),
                                                message.document_id);

                                            // Emit message to frontend with proper format
                                            // Note: We're using the original field values directly to preserve them
                                            let mut message_json = serde_json::json!({
                                                "type": message.message_type,
                                                "data": message.data,
                                                "senderId": message.sender_id.clone().unwrap_or_else(|| peer_id.clone()),
                                                "targetId": message.target_id,
                                                "documentId": message.document_id,
                                            });

                                            // Add peer metadata for handshake messages
                                            if let Some(metadata) = message.peer_metadata {
                                                message_json["peerMetadata"] = metadata;
                                            }

                                            if let Err(e) = app_handle.emit(
                                                "automerge_message",
                                                serde_json::json!({
                                                    "peerId": peer_id,
                                                    "message": message_json
                                                }),
                                            ) {
                                                eprintln!(
                                                    "Failed to emit automerge_message event: {}",
                                                    e
                                                );
                                            }
                                        }
                                        Err(e) => {
                                            eprintln!(
                                                "Failed to deserialize message from peer {}: {}",
                                                peer_id, e
                                            );
                                        }
                                    }
                                }
                                Err(e) => {
                                    eprintln!(
                                        "Failed to read message from peer {}: {}",
                                        peer_id, e
                                    );
                                }
                            }
                        }
                    });
                }
                Err(e) => {
                    // Connection closed or error
                    println!("Connection to peer {} closed or error: {}", peer_id, e);

                    // Emit disconnection event
                    if let Err(e) = app_handle.emit(
                        "peer_disconnected",
                        serde_json::json!({
                            "peerId": peer_id,
                            "timestamp": chrono::Utc::now().to_rfc3339()
                        }),
                    ) {
                        eprintln!("Failed to emit peer_disconnected event: {}", e);
                    }

                    break;
                }
            }
        }
    }
}

impl Drop for P2PManager {
    fn drop(&mut self) {
        // Cancel the accept task if it's running
        if let Some(task) = self.accept_task.take() {
            task.abort();
        }

        // Close the endpoint if it's initialized
        if let Some(endpoint) = self.endpoint.take() {
            // Spawn a task to close the endpoint gracefully
            tokio::spawn(async move {
                endpoint.close().await;
                println!("P2P endpoint closed");
            });
        }
    }
}
