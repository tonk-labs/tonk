import{Bundle as e,TonkCore as t,initializeTonk as n}from"@tonk/core/slim";const r=5e3;var i={debug:0,info:1,warn:2,error:3,none:4},a=`warn`;function o(){let e=self;return e.SW_LOG_LEVEL&&e.SW_LOG_LEVEL in i?e.SW_LOG_LEVEL:a}function s(e){let t=o();return i[e]>=i[t]}function c(e){return`[SW ${new Date().toISOString()}] ${e.toUpperCase()}:`}function l(e,t,n){if(!s(e))return;let r=c(e),i=e===`debug`?`log`:e;n===void 0?console[i](r,t):console[i](r,t,n)}const u={debug:(e,t)=>l(`debug`,e,t),info:(e,t)=>l(`info`,e,t),warn:(e,t)=>l(`warn`,e,t),error:(e,t)=>l(`error`,e,t),setLevel:e=>{let t=self;t.SW_LOG_LEVEL=e,console.log(`[SW] Log level set to: ${e}`)},getLevel:()=>o()},d=`tonk-sw-state-v1`,f=`/tonk-state/appSlug`,p=`/tonk-state/bundleBytes`,m=`/tonk-state/wsUrl`;async function h(e){try{let t=await caches.open(d);if(e===null)await t.delete(f);else{let n=new Response(JSON.stringify({slug:e}),{headers:{"Content-Type":`application/json`}});await t.put(f,n)}u.debug(`AppSlug persisted to cache`,{slug:e})}catch(e){u.error(`Failed to persist appSlug`,{error:e instanceof Error?e.message:String(e)})}}async function g(){try{let e=await(await caches.open(d)).match(f);return e&&(await e.json()).slug||null}catch(e){return u.error(`Failed to restore appSlug`,{error:e instanceof Error?e.message:String(e)}),null}}async function _(e){try{let t=await caches.open(d);if(e===null)await t.delete(p);else{let n=new Blob([e],{type:`application/octet-stream`}),r=new Response(n,{headers:{"Content-Type":`application/octet-stream`}});await t.put(p,r)}u.debug(`Bundle bytes persisted to cache`,{size:e?e.length:0})}catch(e){u.error(`Failed to persist bundle bytes`,{error:e instanceof Error?e.message:String(e)})}}async function ee(){try{let e=await(await caches.open(d)).match(p);if(!e)return null;let t=await e.arrayBuffer();return new Uint8Array(t)}catch(e){return u.error(`Failed to restore bundle bytes`,{error:e instanceof Error?e.message:String(e)}),null}}async function v(e){try{let t=await caches.open(d);if(e===null)await t.delete(m);else{let n=new Response(JSON.stringify({url:e}),{headers:{"Content-Type":`application/json`}});await t.put(m,n)}u.debug(`WS URL persisted to cache`,{url:e})}catch(e){u.error(`Failed to persist WS URL`,{error:e instanceof Error?e.message:String(e)})}}async function y(){try{let e=await(await caches.open(d)).match(m);return e&&(await e.json()).url||null}catch(e){return u.error(`Failed to restore WS URL`,{error:e instanceof Error?e.message:String(e)}),null}}async function te(){await Promise.all([h(null),_(null),v(null)])}var b={status:`idle`},x=null;function S(){return b}function C(){return x}function w(e){x=e}function T(){return b.status===`active`?b:null}function E(){return b.status===`active`?{tonk:b.tonk,manifest:b.manifest}:null}function D(e){u.debug(`Cleaning up active bundle state`,{bundleId:e.bundleId,watcherCount:e.watchers.size,hasHealthCheck:!!e.healthCheckInterval}),e.healthCheckInterval&&clearInterval(e.healthCheckInterval),e.watchers.forEach((e,t)=>{try{e.stop(),u.debug(`Stopped watcher`,{id:t})}catch(e){u.warn(`Error stopping watcher`,{id:t,error:e instanceof Error?e.message:String(e)})}});try{typeof e.tonk.disconnectWebsocket==`function`&&(e.tonk.disconnectWebsocket(),u.debug(`Disconnected WebSocket`))}catch(e){u.warn(`Error disconnecting WebSocket`,{error:e instanceof Error?e.message:String(e)})}}function O(e){let t=b;u.debug(`State transition`,{from:t.status,to:e.status,bundleId:`bundleId`in e?e.bundleId:void 0}),t.status===`active`&&D(t),b=e}function k(e){return b.status===`active`?(b={...b,appSlug:e},!0):!1}function A(e){b.status===`active`&&(b={...b,connectionHealthy:e})}function j(){return b.status===`active`?(b={...b,reconnectAttempts:b.reconnectAttempts+1},b.reconnectAttempts):0}function M(){b.status===`active`&&(b={...b,reconnectAttempts:0})}function N(e){b.status===`active`&&(b={...b,healthCheckInterval:e})}function P(e,t){b.status===`active`&&b.watchers.set(e,t)}function F(e){if(b.status===`active`){let t=b.watchers.get(e);if(t){try{t.stop()}catch(t){u.warn(`Error stopping watcher on remove`,{id:e,error:t instanceof Error?t.message:String(t)})}return b.watchers.delete(e),!0}}return!1}function I(e){if(b.status===`active`)return b.watchers.get(e)}function ne(){return b.status===`active`?Array.from(b.watchers.entries()):[]}function L(e,t){if(console.log(`determinePath START`,{url:e.href,pathname:e.pathname,appSlug:t||`none`}),!t)throw console.error(`determinePath - NO APP SLUG SET`),Error(`No app slug available for ${e.pathname}`);let n=new URL(self.registration?.scope??self.location.href).pathname,r=e.pathname.startsWith(n)?e.pathname.slice(n.length):e.pathname,i=r.replace(/^\/+/,``).split(`/`).filter(Boolean);console.log(`determinePath - segments`,{scopePath:n,strippedPath:r,segments:[...i],firstSegment:i[0]||`none`});let a=i;if(i[0]===t?(a=i.slice(1),console.log(`determinePath - appSlug already present, using remaining segments`,{pathSegments:[...a]})):console.log(`determinePath - appSlug not present, using all segments as path`,{pathSegments:[...a]}),a.length===0||e.pathname.endsWith(`/`)){let e=`${t}/index.html`;return console.log(`determinePath - defaulting to index.html`,{result:e}),e}let o=`${t}/${a.join(`/`)}`;return console.log(`determinePath - returning file path`,{result:o}),o}async function R(e){l(`info`,`Posting response to main thread`,{type:e.type,success:`success`in e?e.success:`N/A`}),(await self.clients.matchAll()).forEach(t=>{t.postMessage(e)})}async function z(e){if(e.bytes){let t=atob(e.bytes),n=new Uint8Array(t.length);for(let e=0;e<t.length;e++)n[e]=t.charCodeAt(e);return new Response(n,{headers:{"Content-Type":e.content.mime||`application/octet-stream`}})}else return new Response(e.content,{headers:{"Content-Type":`application/json`}})}function B(e){let t=new URL(e.request.url),n=e.request.referrer,r=S(),i=T()?.appSlug||null;u.debug(`Fetch event`,{url:t.href,pathname:t.pathname,state:r.status,appSlug:i});let a=e.request.headers.get(`upgrade`);if(a&&a.toLowerCase()===`websocket`){u.debug(`WebSocket upgrade request - passing through`,{url:t.href});return}let o=t.pathname===`/`||t.pathname===``;o&&i&&Promise.all([h(null),_(null)]).catch(e=>{u.error(`Failed to persist state reset`,{error:e})});let s=t.pathname.startsWith(`/app/`),c=t.searchParams.has(`bundleId`),l=[`/app/index.html`,`/app/main.js`,`/app/main.css`,`/app/service-worker-bundled.js`].some(e=>t.pathname===e),d=t.pathname.startsWith(`/app/`)&&[`.otf`,`.ttf`,`.woff`,`.woff2`,`.eot`].some(e=>t.pathname.endsWith(e));if(s&&(c||l||d)){u.debug(`Runtime static asset - passing through`,{pathname:t.pathname});return}if(s&&i!==`app`){u.debug(`Runtime path with non-app slug - passing through`,{pathname:t.pathname});return}if(i&&!o){if(t.pathname.startsWith(`/@vite`)||t.pathname.startsWith(`/@react-refresh`)||t.pathname.startsWith(`/src/`)||t.pathname.startsWith(`/${i}/@vite`)||t.pathname.startsWith(`/${i}/node_modules`)||t.pathname.startsWith(`/${i}/src/`)||t.pathname.startsWith(`/node_modules`)||t.pathname.includes(`__vite__`)||t.searchParams.has(`t`)){u.debug(`Vite HMR asset - proxying to dev server`,{pathname:t.pathname}),e.respondWith((async()=>{try{let e=`http://localhost:4001${t.pathname}${t.search}`,n=await fetch(e),r=new Headers(n.headers);return r.set(`Cache-Control`,`no-cache, no-store, must-revalidate`),r.set(`Pragma`,`no-cache`),r.set(`Expires`,`0`),new Response(n.body,{status:n.status,statusText:n.statusText,headers:r})}catch(e){return u.error(`Failed to fetch Vite asset`,{error:e instanceof Error?e.message:String(e),pathname:t.pathname}),new Response(`Vite dev server unreachable`,{status:502,headers:{"Content-Type":`text/plain`}})}})());return}u.debug(`TONK_SERVE_LOCAL - proxying to dev server`,{pathname:t.pathname}),e.respondWith((async()=>{try{let e=`http://localhost:4001${t.pathname}${t.search}`,n=await fetch(e),r=new Headers(n.headers);return r.set(`Cache-Control`,`no-cache, no-store, must-revalidate`),r.set(`Pragma`,`no-cache`),r.set(`Expires`,`0`),new Response(n.body,{status:n.status,statusText:n.statusText,headers:r})}catch(e){return u.error(`Failed to fetch from local dev server`,{error:e instanceof Error?e.message:String(e),pathname:t.pathname}),new Response(`Local dev server unreachable on port 4001`,{status:502,headers:{"Content-Type":`text/plain`}})}})());return}i&&t.origin===location.origin&&!o?(u.debug(`Processing VFS request`,{pathname:t.pathname,referrer:n}),e.respondWith((async()=>{try{let e=L(t,i);u.debug(`Resolved VFS path`,{path:e,url:t.pathname});let n=C();if(n&&S().status!==`active`){u.debug(`Waiting for initialization`,{status:S().status});try{await Promise.race([n,new Promise((e,t)=>setTimeout(()=>t(Error(`Initialization timeout`)),15e3))])}catch(e){u.warn(`Initialization wait failed or timed out`,{error:e instanceof Error?e.message:String(e)})}}let r=T();if(!r)throw u.error(`Tonk not initialized - cannot handle request`,{status:S().status,path:e}),Error(`Tonk not initialized`);let a=`/${e}`;if(!await r.tonk.exists(a)){u.debug(`File not found, falling back to index.html`,{path:a});let e=`/${i}/index.html`,t=await r.tonk.readFile(e);return z(t)}u.debug(`Serving file from VFS`,{path:a});let o=await r.tonk.readFile(a);return await z(o)}catch(n){return u.error(`Failed to fetch from VFS`,{error:n instanceof Error?n.message:String(n),url:t.href,status:S().status}),u.debug(`Falling back to network request`,{url:t.href}),fetch(e.request)}})())):u.debug(`Ignoring fetch - different origin or root`,{requestOrigin:t.origin,swOrigin:location.origin,isRoot:o})}async function V(){let e=T();if(!e)return!1;try{return await e.tonk.isConnected()}catch(e){return u.error(`performHealthCheck() failed`,{error:e instanceof Error?e.message:String(e)}),!1}}async function H(){let e=T();if(!e){u.error(`Cannot reconnect: no active bundle`);return}let t=e.wsUrl;if(!t){u.error(`Cannot reconnect: wsUrl not stored`);return}let n=j();n>=10&&M(),u.debug(`Attempting to reconnect`,{attempt:n,maxAttempts:10,wsUrl:t}),await R({type:`reconnecting`,attempt:n});try{if(await e.tonk.connectWebsocket(t),await new Promise(e=>setTimeout(e,1e3)),await e.tonk.isConnected())A(!0),M(),u.info(`Reconnection successful`),await R({type:`reconnected`}),await U();else throw Error(`Connection check failed after reconnect attempt`)}catch(e){u.warn(`Reconnection failed`,{error:e instanceof Error?e.message:String(e),attempt:n});let t=Math.min(1e3*2**(n-1),3e4);u.debug(`Scheduling next reconnect attempt`,{delayMs:t,nextAttempt:n+1}),setTimeout(H,t)}}async function U(){let e=ne();u.debug(`Re-establishing watchers after reconnection`,{watcherCount:e.length}),u.debug(`Watcher re-establishment complete`,{watcherCount:e.length}),await R({type:`watchersReestablished`,count:e.length})}function W(){let e=T();if(!e){u.warn(`Cannot start health monitoring: no active bundle`);return}e.healthCheckInterval&&clearInterval(e.healthCheckInterval),u.debug(`Starting health monitoring`,{intervalMs:r});let t=setInterval(async()=>{let e=await V(),n=T();if(!n){clearInterval(t);return}!e&&n.connectionHealthy?(A(!1),u.warn(`Connection lost, starting reconnection attempts`),await R({type:`disconnected`}),H()):e&&!n.connectionHealthy&&(A(!0),M(),u.debug(`Connection health restored`))},r);N(t)}var G=null,K=!1;async function q(){if(K){u.debug(`WASM already initialized`);return}return G?(u.debug(`WASM initialization in progress, waiting...`),G):(u.debug(`Starting WASM initialization`),G=(async()=>{try{let e=`/tonk_core_bg.wasm?t=${Date.now()}`;await n({wasmPath:e}),K=!0,u.info(`WASM initialization completed`)}catch(e){throw G=null,K=!1,u.error(`WASM initialization failed`,{error:e instanceof Error?e.message:String(e)}),e}})(),G)}async function J(e){return u.debug(`Waiting for PathIndex to sync from remote...`),new Promise(t=>{let n=!1,r=null,i=setTimeout(()=>{if(r)try{r.stop()}catch(e){u.warn(`Error stopping PathIndex watcher on timeout`,{error:e instanceof Error?e.message:String(e)})}n||(u.debug(`No PathIndex changes detected after 1s - proceeding`),t())},1e3);e.watchDirectory(`/`,e=>{if(!n){if(n=!0,u.debug(`PathIndex synced from remote`,{documentType:e.type}),clearTimeout(i),r)try{r.stop()}catch(e){u.warn(`Error stopping PathIndex watcher after sync`,{error:e instanceof Error?e.message:String(e)})}t()}}).then(e=>{r=e,u.debug(`PathIndex watcher established`,{watcherId:e?.document_id||`unknown`})}).catch(e=>{u.error(`Failed to establish PathIndex watcher`,{error:e.message}),clearTimeout(i),t()})})}async function Y(){try{let n=await g(),r=await ee(),i=await y();if(!n||!r){u.debug(`No cached state found, waiting for initialization message`,{hasSlug:!!n,hasBundle:!!r});return}u.info(`Auto-initializing from cache`,{slug:n,bundleSize:r.length}),await q();let a=await(await e.fromBytes(r)).getManifest();u.debug(`Bundle and manifest restored from cache`,{rootId:a.rootId});let o=await t.fromBytes(r,{storage:{type:`indexeddb`}});u.debug(`TonkCore created from cached bundle`);let s=i||`${`http://localhost:8081`.replace(/^http/,`ws`)}`;!i&&s&&await v(s),u.debug(`Connecting to websocket...`,{wsUrl:s,localRootId:a.rootId}),await o.connectWebsocket(s),u.debug(`Websocket connected`),await J(o),u.info(`Auto-initialization complete`),O({status:`active`,bundleId:a.rootId,tonk:o,manifest:a,appSlug:n,wsUrl:s,healthCheckInterval:null,watchers:new Map,connectionHealthy:!0,reconnectAttempts:0}),W()}catch(e){u.error(`Auto-initialization failed`,{error:e instanceof Error?e.message:String(e)}),O({status:`idle`}),await te(),(await self.clients.matchAll()).forEach(e=>{e.postMessage({type:`needsReinit`,appSlug:null,reason:`Auto-initialization failed`})})}}async function X(n,r,i,a){u.debug(`Loading new bundle`,{byteLength:n.length,serverUrl:r,hasCachedManifest:!!a});try{let i=S();await q();let o;if(a)u.info(`Using cached manifest, skipping Bundle.fromBytes`,{rootId:a.rootId}),o=a;else{u.debug(`No cached manifest, parsing bundle`,{byteLength:n.length});let t=await e.fromBytes(n);o=await t.getManifest(),t.free(),u.debug(`Bundle manifest extracted`,{rootId:o.rootId})}if(i.status===`active`&&i.manifest.rootId===o.rootId)return u.debug(`Bundle already loaded with same rootId, skipping reload`,{rootId:o.rootId}),{success:!0,skipped:!0};u.debug(`Creating new TonkCore from bundle bytes`);let s=await t.fromBytes(n,{storage:{type:`indexeddb`}});u.debug(`New TonkCore created successfully`,{rootId:o.rootId});let c=new URLSearchParams(self.location.search).get(`bundle`),l=`${r.replace(/^http/,`ws`)}`;if(c)try{let e=atob(c),t=JSON.parse(e);t.wsUrl&&(l=t.wsUrl)}catch(e){u.warn(`Could not parse bundle config for wsUrl`,{error:e instanceof Error?e.message:String(e)})}u.debug(`Determined websocket URL`,{wsUrl:l,serverUrl:r}),await v(l),u.debug(`Connecting new tonk to websocket`,{wsUrl:l,localRootId:o.rootId}),l&&(await s.connectWebsocket(l),u.debug(`Websocket connection established`),await J(s),u.debug(`PathIndex sync complete after loadBundle`));let d=S(),f=d.status===`active`?d.appSlug:o.entrypoints?.[0]||`app`;return O({status:`active`,bundleId:o.rootId,tonk:s,manifest:o,appSlug:f,wsUrl:l,healthCheckInterval:null,watchers:new Map,connectionHealthy:!0,reconnectAttempts:0}),W(),await _(n),u.debug(`Bundle bytes persisted to cache`),u.info(`Bundle loaded successfully`,{rootId:o.rootId}),{success:!0}}catch(e){return u.error(`Failed to load bundle`,{error:e instanceof Error?e.message:String(e)}),O({status:`error`,error:e instanceof Error?e:Error(String(e))}),{success:!1,error:e instanceof Error?e.message:String(e)}}}async function Z(e){u.debug(`Loading new bundle`,{byteLength:e.bundleBytes.byteLength,serverUrl:e.serverUrl,hasCachedManifest:!!e.manifest});let t=e.serverUrl||`http://localhost:8081`,n=new Uint8Array(e.bundleBytes),r=await X(n,t,e.id,e.manifest);R({type:`loadBundle`,id:e.id,success:r.success,skipped:r.skipped,error:r.error})}async function re(e){u.debug(`Converting tonk to bytes`);try{let t=E();if(!t)throw Error(`Tonk not initialized`);let n=await t.tonk.toBytes(),r=t.manifest.rootId;u.debug(`Tonk converted to bytes`,{byteLength:n.length,rootId:r}),R({type:`toBytes`,id:e.id,success:!0,data:n,rootId:r})}catch(t){u.error(`Failed to convert tonk to bytes`,{error:t instanceof Error?t.message:String(t)}),R({type:`toBytes`,id:e.id,success:!1,error:t instanceof Error?t.message:String(t)})}}async function ie(t){u.debug(`Forking tonk to bytes`);try{let n=E();if(!n)throw Error(`Tonk not initialized`);let r=await n.tonk.forkToBytes(),i=(await(await e.fromBytes(r)).getManifest()).rootId;u.debug(`Tonk forked to bytes`,{byteLength:r.length,rootId:i}),R({type:`forkToBytes`,id:t.id,success:!0,data:r,rootId:i})}catch(e){u.error(`Failed to fork tonk to bytes`,{error:e instanceof Error?e.message:String(e)}),R({type:`forkToBytes`,id:t.id,success:!1,error:e instanceof Error?e.message:String(e)})}}async function ae(e){u.debug(`Listing directory`,{path:e.path});try{let t=E();if(!t)throw Error(`Tonk not initialized`);let n=await t.tonk.listDirectory(e.path);u.debug(`Directory listed`,{path:e.path,fileCount:Array.isArray(n)?n.length:`unknown`}),R({type:`listDirectory`,id:e.id,success:!0,data:n})}catch(t){u.error(`Failed to list directory`,{path:e.path,error:t instanceof Error?t.message:String(t)}),R({type:`listDirectory`,id:e.id,success:!1,error:t instanceof Error?t.message:String(t)})}}async function oe(e){u.debug(`Reading file`,{path:e.path});try{let t=E();if(!t)throw Error(`Tonk not initialized`);let n=await t.tonk.readFile(e.path);u.debug(`File read successfully`,{path:e.path}),R({type:`readFile`,id:e.id,success:!0,data:n})}catch(t){u.error(`Failed to read file`,{path:e.path,error:t instanceof Error?t.message:String(t)}),R({type:`readFile`,id:e.id,success:!1,error:t instanceof Error?t.message:String(t)})}}async function se(e){u.debug(`Writing file`,{path:e.path,create:e.create,hasBytes:!!e.content.bytes});try{let t=E();if(!t)throw Error(`Tonk not initialized`);let n=e.content.content;e.create?(u.debug(`Creating new file`,{path:e.path}),e.content.bytes?await t.tonk.createFileWithBytes(e.path,n,e.content.bytes):await t.tonk.createFile(e.path,n)):(u.debug(`Setting existing file`,{path:e.path}),e.content.bytes?await t.tonk.setFileWithBytes(e.path,n,e.content.bytes):await t.tonk.setFile(e.path,n)),u.debug(`File write completed`,{path:e.path}),R({type:`writeFile`,id:e.id,success:!0})}catch(t){u.error(`Failed to write file`,{path:e.path,create:e.create,error:t instanceof Error?t.message:String(t)}),R({type:`writeFile`,id:e.id,success:!1,error:t instanceof Error?t.message:String(t)})}}async function ce(e){u.debug(`Deleting file`,{path:e.path});try{let t=E();if(!t)throw Error(`Tonk not initialized`);await t.tonk.deleteFile(e.path),u.debug(`File deleted successfully`,{path:e.path}),R({type:`deleteFile`,id:e.id,success:!0})}catch(t){u.error(`Failed to delete file`,{path:e.path,error:t instanceof Error?t.message:String(t)}),R({type:`deleteFile`,id:e.id,success:!1,error:t instanceof Error?t.message:String(t)})}}async function le(e){u.debug(`Renaming file or directory`,{oldPath:e.oldPath,newPath:e.newPath});try{let t=E();if(!t)throw Error(`Tonk not initialized`);await t.tonk.rename(e.oldPath,e.newPath),u.debug(`Rename completed`,{oldPath:e.oldPath,newPath:e.newPath}),R({type:`rename`,id:e.id,success:!0})}catch(t){u.error(`Failed to rename`,{oldPath:e.oldPath,newPath:e.newPath,error:t instanceof Error?t.message:String(t)}),R({type:`rename`,id:e.id,success:!1,error:t instanceof Error?t.message:String(t)})}}async function ue(e){u.debug(`Checking file existence`,{path:e.path});try{let t=E();if(!t)throw Error(`Tonk not initialized`);let n=await t.tonk.exists(e.path);u.debug(`File existence check completed`,{path:e.path,exists:n}),R({type:`exists`,id:e.id,success:!0,data:n})}catch(t){u.error(`Failed to check file existence`,{path:e.path,error:t instanceof Error?t.message:String(t)}),R({type:`exists`,id:e.id,success:!1,error:t instanceof Error?t.message:String(t)})}}async function de(e){u.debug(`Updating file with smart diff`,{path:e.path});try{let t=E();if(!t)throw Error(`Tonk not initialized`);let n=e.content,r=await t.tonk.updateFile(e.path,n);u.debug(`File update completed`,{path:e.path,changed:r}),R({type:`updateFile`,id:e.id,success:!0,data:r})}catch(t){u.error(`Failed to update file`,{path:e.path,error:t instanceof Error?t.message:String(t)}),R({type:`updateFile`,id:e.id,success:!1,error:t instanceof Error?t.message:String(t)})}}async function fe(e){u.debug(`Patching file`,{path:e.path,jsonPath:e.jsonPath});try{let t=E();if(!t)throw Error(`Tonk not initialized`);let n=e.value,r=await t.tonk.patchFile(e.path,e.jsonPath,n);u.debug(`File patch completed`,{path:e.path,result:r}),R({type:`patchFile`,id:e.id,success:!0,data:r})}catch(t){u.error(`Failed to patch file`,{path:e.path,error:t instanceof Error?t.message:String(t)}),R({type:`patchFile`,id:e.id,success:!1,error:t instanceof Error?t.message:String(t)})}}async function pe(e){u.debug(`Handling VFS init message`,{manifestSize:e.manifest.byteLength,wsUrl:e.wsUrl});try{let e=S();if(e.status===`active`){u.debug(`Tonk already initialized`),R({type:`init`,success:!0});return}if(e.status===`loading`){u.debug(`Tonk is loading, waiting for completion`);try{await e.promise,u.debug(`Tonk loading completed`),R({type:`init`,success:!0})}catch(e){u.error(`Tonk loading failed`,{error:e instanceof Error?e.message:String(e)}),R({type:`init`,success:!1,error:e instanceof Error?e.message:String(e)})}return}if(e.status===`error`){u.error(`Tonk initialization failed previously`,{error:e.error.message}),R({type:`init`,success:!1,error:e.error.message});return}u.warn(`Tonk is uninitialized, this is unexpected`),R({type:`init`,success:!1,error:`Tonk not initialized`})}catch(e){u.error(`Failed to handle init message`,{error:e instanceof Error?e.message:String(e)}),R({type:`init`,success:!1,error:e instanceof Error?e.message:String(e)})}}async function me(n){u.debug(`Initializing from URL`,{manifestUrl:n.manifestUrl,wasmUrl:n.wasmUrl});try{let r=n.manifestUrl||`http://localhost:8081/.manifest.tonk`,i=n.wsUrl||`http://localhost:8081`.replace(/^http/,`ws`);await q(),u.debug(`Fetching manifest from URL`,{manifestUrl:r});let a=await fetch(r),o=new Uint8Array(await a.arrayBuffer());u.debug(`Manifest bytes loaded`,{byteLength:o.length});let s=await(await e.fromBytes(o)).getManifest();u.debug(`Bundle and manifest created`),u.debug(`Creating TonkCore from manifest bytes`);let c=await t.fromBytes(o,{storage:{type:`indexeddb`}});u.debug(`TonkCore created`),await v(i),u.debug(`Connecting to websocket`,{wsUrl:i}),await c.connectWebsocket(i),u.debug(`Websocket connection established`),await J(c),u.debug(`PathIndex sync complete`),O({status:`active`,bundleId:s.rootId,tonk:c,manifest:s,appSlug:s.entrypoints?.[0]||`app`,wsUrl:i,healthCheckInterval:null,watchers:new Map,connectionHealthy:!0,reconnectAttempts:0}),W(),await _(o),u.debug(`Bundle bytes persisted`),u.info(`Initialized from URL successfully`),R({type:`initializeFromUrl`,id:n.id,success:!0})}catch(e){u.error(`Failed to initialize from URL`,{error:e instanceof Error?e.message:String(e)}),O({status:`error`,error:e instanceof Error?e:Error(String(e))}),R({type:`initializeFromUrl`,id:n.id,success:!1,error:e instanceof Error?e.message:String(e)})}}async function Q(n){u.debug(`Initializing from bytes`,{byteLength:n.bundleBytes.byteLength,serverUrl:n.serverUrl});try{let r=n.serverUrl||`http://localhost:8081`,i=n.wsUrl||r.replace(/^http/,`ws`);u.debug(`Using server URL`,{serverUrl:r}),await q();let a=new Uint8Array(n.bundleBytes);u.debug(`Creating bundle from bytes`,{byteLength:a.length});let o=await(await e.fromBytes(a)).getManifest();u.debug(`Bundle and manifest created`,{rootId:o.rootId}),u.debug(`Creating TonkCore from bundle bytes`);let s=await t.fromBytes(a,{storage:{type:`indexeddb`}});u.debug(`TonkCore created`),u.debug(`Connecting to websocket`,{wsUrl:i}),i&&(await s.connectWebsocket(i),u.debug(`Websocket connection established`),await J(s),u.debug(`PathIndex sync complete`)),O({status:`active`,bundleId:o.rootId,tonk:s,manifest:o,appSlug:o.entrypoints?.[0]||`app`,wsUrl:i,healthCheckInterval:null,watchers:new Map,connectionHealthy:!0,reconnectAttempts:0}),W(),await _(a),u.debug(`Bundle bytes persisted`),u.info(`Initialized from bytes successfully`),R({type:`initializeFromBytes`,id:n.id,success:!0})}catch(e){u.error(`Failed to initialize from bytes`,{error:e instanceof Error?e.message:String(e)}),O({status:`error`,error:e instanceof Error?e:Error(String(e))}),R({type:`initializeFromBytes`,id:n.id,success:!1,error:e instanceof Error?e.message:String(e)})}}async function he(e){u.debug(`Getting server URL`),R({type:`getServerUrl`,id:e.id,success:!0,data:`http://localhost:8081`})}async function ge(e){u.debug(`Getting manifest`);try{let t=E();if(!t)throw Error(`Tonk not initialized`);R({type:`getManifest`,id:e.id,success:!0,data:t.manifest})}catch(t){u.error(`Failed to get manifest`,{error:t instanceof Error?t.message:String(t)}),R({type:`getManifest`,id:e.id,success:!1,error:t instanceof Error?t.message:String(t)})}}async function _e(){let e=S();u.debug(`Ping received`),R({type:`ready`,status:e.status,needsBundle:e.status!==`active`})}async function ve(e){S().status===`active`&&k(e.slug),await h(e.slug),u.debug(`App slug set and persisted`,{slug:e.slug})}async function ye(e){u.debug(`Starting file watch`,{path:e.path,watchId:e.id});try{let t=E();if(!t)throw Error(`Tonk not initialized`);let n=await t.tonk.watchFile(e.path,t=>{u.debug(`File change detected`,{watchId:e.id,path:e.path}),R({type:`fileChanged`,watchId:e.id,documentData:t})});n&&P(e.id,n),u.debug(`File watch started`,{path:e.path,watchId:e.id}),R({type:`watchFile`,id:e.id,success:!0})}catch(t){u.error(`Failed to start file watch`,{path:e.path,error:t instanceof Error?t.message:String(t)}),R({type:`watchFile`,id:e.id,success:!1,error:t instanceof Error?t.message:String(t)})}}async function be(e){u.debug(`Stopping file watch`,{watchId:e.id});try{I(e.id)?(u.debug(`Found watcher, stopping it`,{watchId:e.id}),F(e.id),u.debug(`File watch stopped`,{watchId:e.id})):u.debug(`No watcher found for ID`,{watchId:e.id}),R({type:`unwatchFile`,id:e.id,success:!0})}catch(t){u.error(`Failed to stop file watch`,{watchId:e.id,error:t instanceof Error?t.message:String(t)}),R({type:`unwatchFile`,id:e.id,success:!1,error:t instanceof Error?t.message:String(t)})}}async function xe(e){u.debug(`Starting directory watch`,{path:e.path,watchId:e.id});try{let t=E();if(!t)throw Error(`Tonk not initialized`);let n=await t.tonk.watchDirectory(e.path,t=>{u.debug(`Directory change detected`,{watchId:e.id,path:e.path}),R({type:`directoryChanged`,watchId:e.id,path:e.path,changeData:t})});n&&P(e.id,n),u.debug(`Directory watch started`,{path:e.path,watchId:e.id}),R({type:`watchDirectory`,id:e.id,success:!0})}catch(t){u.error(`Failed to start directory watch`,{path:e.path,error:t instanceof Error?t.message:String(t)}),R({type:`watchDirectory`,id:e.id,success:!1,error:t instanceof Error?t.message:String(t)})}}async function Se(e){u.debug(`Stopping directory watch`,{watchId:e.id});try{I(e.id)?(u.debug(`Found directory watcher, stopping it`,{watchId:e.id}),F(e.id),u.debug(`Directory watch stopped`,{watchId:e.id})):u.debug(`No directory watcher found for ID`,{watchId:e.id}),R({type:`unwatchDirectory`,id:e.id,success:!0})}catch(t){u.error(`Failed to stop directory watch`,{watchId:e.id,error:t instanceof Error?t.message:String(t)}),R({type:`unwatchDirectory`,id:e.id,success:!1,error:t instanceof Error?t.message:String(t)})}}var Ce=[`init`,`loadBundle`,`initializeFromUrl`,`initializeFromBytes`,`getServerUrl`,`ping`,`setAppSlug`];async function we(e){let t=e.type,n=e.id;u.debug(`Received message`,{type:t,id:n||`N/A`});let r=S();if(t===`setAppSlug`){await ve({slug:e.slug});return}if(t===`ping`){await _e();return}if(r.status!==`active`&&!Ce.includes(t)){u.warn(`Operation attempted before VFS initialization`,{type:t,status:r.status}),n&&R({type:t,id:n,success:!1,error:`VFS not initialized. Please load a bundle first.`});return}switch(t){case`init`:await pe({...n!==void 0&&{id:n},manifest:e.manifest,...e.wsUrl!==void 0&&{wsUrl:e.wsUrl}});break;case`initializeFromUrl`:await me({...n!==void 0&&{id:n},...e.manifestUrl!==void 0&&{manifestUrl:e.manifestUrl},...e.wasmUrl!==void 0&&{wasmUrl:e.wasmUrl},...e.wsUrl!==void 0&&{wsUrl:e.wsUrl}});break;case`initializeFromBytes`:await Q({...n!==void 0&&{id:n},bundleBytes:e.bundleBytes,...e.serverUrl!==void 0&&{serverUrl:e.serverUrl},...e.wsUrl!==void 0&&{wsUrl:e.wsUrl}});break;case`getServerUrl`:await he({id:n});break;case`getManifest`:await ge({id:n});break;case`loadBundle`:await Z({...n!==void 0&&{id:n},bundleBytes:e.bundleBytes,...e.serverUrl!==void 0&&{serverUrl:e.serverUrl},...e.manifest!==void 0&&{manifest:e.manifest}});break;case`toBytes`:await re({id:n});break;case`forkToBytes`:await ie({id:n});break;case`readFile`:await oe({id:n,path:e.path});break;case`writeFile`:await se({id:n,path:e.path,...e.create!==void 0&&{create:e.create},content:e.content});break;case`deleteFile`:await ce({id:n,path:e.path});break;case`rename`:await le({id:n,oldPath:e.oldPath,newPath:e.newPath});break;case`exists`:await ue({id:n,path:e.path});break;case`patchFile`:await fe({id:n,path:e.path,jsonPath:e.jsonPath,value:e.value});break;case`updateFile`:await de({id:n,path:e.path,content:e.content});break;case`listDirectory`:await ae({id:n,path:e.path});break;case`watchFile`:await ye({id:n,path:e.path});break;case`unwatchFile`:await be({id:n});break;case`watchDirectory`:await xe({id:n,path:e.path});break;case`unwatchDirectory`:await Se({id:n});break;default:u.warn(`Unknown message type`,{type:t}),n&&R({type:t,id:n,success:!1,error:`Unknown message type: ${t}`})}}var $=self;u.info(`Service worker starting`,{version:`mj05cbn8`,buildTime:`2025-12-10T15:10:47.539Z`,location:self.location.href}),u.debug(`Checking for cached state`),w(Y()),self.addEventListener(`install`,e=>{u.info(`Service worker installing`),$.skipWaiting(),u.debug(`skipWaiting called`)}),self.addEventListener(`activate`,e=>{u.info(`Service worker activating`),e.waitUntil((async()=>{await $.clients.claim(),u.debug(`Clients claimed`);let e=await $.clients.matchAll();e.forEach(e=>{e.postMessage({type:`ready`,needsBundle:!0})}),u.info(`Service worker activated`,{clientCount:e.length})})())}),self.addEventListener(`message`,async e=>{u.debug(`Message received`,{type:e.data?.type});try{await we(e.data)}catch(e){u.error(`Error handling message`,{error:e instanceof Error?e.message:String(e)})}}),self.addEventListener(`fetch`,e=>{B(e)}),u.debug(`VFS Service Worker initialized`);