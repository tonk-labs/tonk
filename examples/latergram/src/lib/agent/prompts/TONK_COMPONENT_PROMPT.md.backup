# Tonk Component Creation Guidelines for LLM Agents

## Critical Component Format Requirements

When creating React components in the Tonk environment, you MUST follow these exact patterns.
Components are compiled and hot-reloaded through our bespoke HMR system.

## Component File Structure

### Basic Function Component Pattern

```tsx
interface ComponentProps {
  prop1: string;
  prop2?: number;
  onAction?: (value: string) => void;
}

const ComponentName: React.FC<ComponentProps> = ({ prop1, prop2 = 0, onAction }) => {
  const [state, setState] = useState<string>('');

  useEffect(() => {
    // Effect logic
  }, [dependency]);

  const handleClick = () => {
    if (onAction) {
      onAction(state);
    }
  };

  return (
    <Box p={4} bg="white" borderRadius="lg" shadow="md">
      <Heading>{prop1}</Heading>
      <Button onClick={handleClick}>Click me</Button>
    </Box>
  );
};

export default ComponentName;
```

## Critical Rules for Components

### 1. Available Libraries (NO IMPORTS NEEDED)

The following are available globally without imports:

**React & Hooks:**
- `React`, `useState`, `useEffect`, `useCallback`, `useMemo`, `useRef`, `useReducer`, `useContext`, `Fragment`

**Chakra UI v3 (USE THIS AS PRIMARY UI LIBRARY):**
- All Chakra UI components: `Box`, `Button`, `Heading`, `Text`, `Input`, `Stack`, etc.
- All Chakra UI hooks: `useDisclosure`, `useBreakpoint`, etc.
- Chakra UI is the primary component library - use it for all UI elements

**React Router:**
- `Link`, `NavLink`, `useNavigate`, `useLocation`, `useParams`, `useSearchParams`

**Zustand (for stores):**
- `create`, `sync`

**Global Utilities:**
- None currently available (toast notifications are not supported in dynamic components)

### 2. Component Definition

- **MUST** use typed props with TypeScript interfaces
- **MUST** use `React.FC<Props>` or function declaration with typed props
- **MUST** use default export
- Component name should be PascalCase
- **NO IMPORTS** - all libraries are globally available

### 3. Hooks Rules

- All hooks **MUST** be at the top level of the component
- Never call hooks inside conditions, loops, or nested functions
- Order: useState, useReducer, useContext, useEffect, custom hooks

### 4. File Naming

- Component files: `/src/components/ComponentName.tsx`
- Use PascalCase for component filenames
- Match filename to component name

### 5. Store Integration

When using Tonk stores in components, NEVER import the store - it is hotlinked

```tsx
interface MyComponentProps {
  title: string;
}

const MyComponent: React.FC<MyComponentProps> = ({ title }) => {
  const { data, isLoading, fetchData } = useExampleStore();

  useEffect(() => {
    fetchData();
  }, []);

  if (isLoading) {
    return <Spinner />;
  }

  return (
    <Box p={4} bg="white" borderRadius="lg" shadow="md">
      <Heading size="lg" mb={4}>{title}</Heading>
      <Text>{data}</Text>
    </Box>
  );
};

export default MyComponent;
```

### 6. Navigation with React Router

For navigation between pages, use React Router APIs that are available in the Tonk environment:

```tsx
const NavigationComponent: React.FC = () => {
  const navigate = useNavigate();
  const location = useLocation();
  const params = useParams();

  const handleNavigation = () => {
    navigate('/about');
    navigate('/products', { replace: true });
  };

  return (
    <Stack spacing={4}>
      <Link to="/about" color="blue.500">
        About Us
      </Link>

      <Button as={Link} to="/products" colorScheme="blue">
        View Products
      </Button>

      <NavLink
        to="/dashboard"
        className={({ isActive }) => (isActive ? 'text-blue-600 font-bold' : 'text-gray-600')}
      >
        Dashboard
      </NavLink>

      <Button onClick={handleNavigation}>Go to About</Button>
    </Stack>
  );
};
```

**CRITICAL Navigation Rules:**

- ✅ **ALWAYS** use absolute paths starting with `/` (e.g., `/about`, `/products`)
- ✅ **NEVER** use relative paths without `/` (e.g., `about`, `products`)
- ✅ **USE** `<Link>` for internal navigation instead of `<a>` tags
- ✅ **USE** `useNavigate()` for programmatic navigation
- ❌ **NEVER** use `window.location` for navigation
- ❌ **NEVER** use `<a href="/path">` for internal links

## UI Component Library - Chakra UI v3

**USE CHAKRA UI v3 AS THE PRIMARY COMPONENT LIBRARY**

All Chakra UI components and hooks are available globally without imports.

### Common Components:
- **Layout:** `Box`, `Container`, `Flex`, `Grid`, `Stack`, `VStack`, `HStack`, `Wrap`, `Center`, `Spacer`
- **Typography:** `Heading`, `Text`
- **Forms:** `Input`, `Textarea`, `Select`, `Checkbox`, `Radio`, `Switch`, `Field`
- **Buttons:** `Button`, `IconButton`
- **Feedback:** `Alert`, `Spinner`, `ProgressCircle`, `ProgressBar`
- **Overlay:** `Modal`, `Drawer`, `Popover`, `Tooltip`
- **Data Display:** `Badge`, `Card`, `Table`, `Tag`, `Avatar`, `Image`
- **Disclosure:** `Accordion`, `Tabs`, `Collapsible`

### Common Hooks:
- `useDisclosure` - For modals, drawers, collapsibles
- `useBreakpoint`, `useBreakpointValue` - Responsive design
- `useChakraContext` - Access Chakra system


### Modal Example:

```tsx
const ModalExample: React.FC = () => {
  const { isOpen, onOpen, onClose } = useDisclosure();

  return (
    <Box>
      <Button onClick={onOpen}>Open Modal</Button>

      <Modal.Root open={isOpen} onOpenChange={({ open }) => !open && onClose()}>
        <Modal.Backdrop />
        <Modal.Positioner>
          <Modal.Content>
            <Modal.Header>
              <Modal.Title>Modal Title</Modal.Title>
              <Modal.CloseTrigger />
            </Modal.Header>
            <Modal.Body>
              <Text>Modal content goes here</Text>
            </Modal.Body>
            <Modal.Footer>
              <Button variant="outline" onClick={onClose}>
                Cancel
              </Button>
              <Button colorScheme="blue" onClick={onClose}>
                Save
              </Button>
            </Modal.Footer>
          </Modal.Content>
        </Modal.Positioner>
      </Modal.Root>
    </Box>
  );
};
```

### Drawer Example:

```tsx
const DrawerExample: React.FC = () => {
  const { isOpen, onOpen, onClose } = useDisclosure();

  return (
    <Box>
      <Button onClick={onOpen}>Open Drawer</Button>

      <Drawer.Root open={isOpen} onOpenChange={({ open }) => !open && onClose()} placement="end">
        <Drawer.Backdrop />
        <Drawer.Positioner>
          <Drawer.Content>
            <Drawer.Header>
              <Drawer.Title>Drawer Title</Drawer.Title>
              <Drawer.CloseTrigger />
            </Drawer.Header>
            <Drawer.Body>
              <Text>Drawer content</Text>
            </Drawer.Body>
            <Drawer.Footer>
              <Button variant="outline" onClick={onClose}>
                Cancel
              </Button>
            </Drawer.Footer>
          </Drawer.Content>
        </Drawer.Positioner>
      </Drawer.Root>
    </Box>
  );
};
```

### Accordion Example:

```tsx
const AccordionExample: React.FC = () => {
  return (
    <Accordion.Root>
      <Accordion.Item value="item-1">
        <Accordion.ItemTrigger>
          <Accordion.ItemIndicator />
          Section 1
        </Accordion.ItemTrigger>
        <Accordion.ItemContent>
          <Text>Content for section 1</Text>
        </Accordion.ItemContent>
      </Accordion.Item>

      <Accordion.Item value="item-2">
        <Accordion.ItemTrigger>
          <Accordion.ItemIndicator />
          Section 2
        </Accordion.ItemTrigger>
        <Accordion.ItemContent>
          <Text>Content for section 2</Text>
        </Accordion.ItemContent>
      </Accordion.Item>
    </Accordion.Root>
  );
};
```

### Collapsible Example:

```tsx
const CollapsibleExample: React.FC = () => {
  const { isOpen, onToggle } = useDisclosure();

  return (
    <Collapsible.Root open={isOpen} onOpenChange={({ open }) => !open && onToggle()}>
      <Collapsible.Trigger asChild>
        <Button>Toggle Content</Button>
      </Collapsible.Trigger>
      <Collapsible.Content>
        <Box p={4} bg="gray.50" mt={2}>
          <Text>Hidden content that can be toggled</Text>
        </Box>
      </Collapsible.Content>
    </Collapsible.Root>
  );
};
```



**IMPORTANT: Toast Notifications**

Toast notifications using the `toaster` API are currently not supported in dynamic components due to Chakra UI v3 context requirements. Avoid using toast notifications in your components. If you need to show feedback to users, use inline UI elements like Alert boxes instead.

Example of using Alert instead of toast:

```tsx
const [showSuccess, setShowSuccess] = useState(false);

const handleAction = () => {
  // Do something
  setShowSuccess(true);
  setTimeout(() => setShowSuccess(false), 3000);
};

return (
  <Box>
    {showSuccess && (
      <Alert.Root status="success" mb={4}>
        <Alert.Indicator />
        <Alert.Title>Success!</Alert.Title>
        <Alert.Description>Action completed successfully</Alert.Description>
      </Alert.Root>
    )}
    <Button onClick={handleAction}>Do Action</Button>
  </Box>
);
```

# IMPORTANT

## Forms and Inputs

When you create input of forms that use a store- the input boxes MUST be managed or otherwise the
input boxes will constantly reset after typing and the users can't use your forms.

## Chakra UI v3 Component Patterns

Chakra UI v3 uses compound component patterns with dot notation (e.g., `Modal.Root`, `Drawer.Backdrop`).
Always check the component structure and use the proper compound pattern.

## Common Mistakes to Avoid

### Button Icons

When using icons or emojis in buttons, **DO NOT** wrap them in `<Text>` components:

```tsx
// ❌ WRONG - This causes React error #130
<Button leftIcon={<Text>▶️</Text>}>Start</Button>

// ✅ CORRECT - Use span or just include emoji in button text
<Button leftIcon={<span>▶️</span>}>Start</Button>

// ✅ EVEN BETTER - Just put emoji in the button text
<Button>▶️ Start</Button>
```

The `leftIcon` and `rightIcon` props expect simple React elements, not wrapped components.

### Progress Components

When using `ProgressCircle` or `ProgressBar`, ensure you're using the correct v3 API:

```tsx
// ✅ CORRECT - Chakra v3 ProgressCircle
<ProgressCircle.Root value={progress} size="lg">
  <ProgressCircle.Circle>
    <ProgressCircle.Track />
    <ProgressCircle.Range />
  </ProgressCircle.Circle>
  <ProgressCircle.ValueText>{progress}%</ProgressCircle.ValueText>
</ProgressCircle.Root>
```

Always use the compound component pattern with proper Root/Circle/Track/Range structure.

## Store Subscription Anti-Patterns

### Problem: Parent Component Causing Child Re-renders

**CRITICAL:** When a parent component subscribes to store state that changes frequently, it can cause child components to re-render and lose focus on inputs.

#### ❌ BAD - Causes Input Focus Loss:

```tsx
// Parent component subscribing to entire array
const ContactPage: React.FC = () => {
  const { submissions } = useContactStore(); // BAD - re-renders on every change
  
  return (
    <Box>
      <ContactForm /> {/* This will lose focus on every store update */}
      <Text>Total: {submissions.length}</Text>
    </Box>
  );
};
```

#### ✅ GOOD - Use Selective Subscriptions:

```tsx
// Parent component with optimized subscription
const ContactPage: React.FC = () => {
  // Only subscribe to the specific value you need
  const submissionsLength = useContactStore((state) => state.submissions.length);
  
  return (
    <Box>
      <ContactForm /> {/* Won't re-render unless ContactForm's own state changes */}
      <Text>Total: {submissionsLength}</Text>
    </Box>
  );
};
```

### Rules for Store Subscriptions:

1. **Never subscribe to arrays/objects if you only need a count or derived value**
   ```tsx
   // ❌ BAD
   const { items } = useStore();
   const count = items.length;
   
   // ✅ GOOD
   const count = useStore((state) => state.items.length);
   ```

2. **Use selectors to extract only what you need**
   ```tsx
   // ❌ BAD - subscribes to entire user object
   const { user } = useStore();
   const userName = user.name;
   
   // ✅ GOOD - only subscribes to name
   const userName = useStore((state) => state.user.name);
   ```

3. **If a component has input fields, minimize parent re-renders**
   - Parent components with forms should use minimal store subscriptions
   - Move store subscriptions to child components when possible
   - Use `React.memo()` on form components if parent must re-render

4. **Components displaying lists should subscribe selectively**
   ```tsx
   // ❌ BAD - re-renders entire list on any item change
   const { items } = useStore();
   return items.map(item => <Item key={item.id} data={item} />);
   
   // ✅ GOOD - only re-renders when items array reference changes
   const items = useStore((state) => state.items);
   return items.map(item => <Item key={item.id} data={item} />);
   
   // ✅ EVEN BETTER - use stable selectors with equality check
   const items = useStore((state) => state.items, shallow);
   ```

### Common Symptoms of This Issue:

- Input fields lose focus after every keystroke
- Forms feel "jumpy" or unresponsive
- Cursor position resets in text areas
- Components flash or flicker during typing

### How to Debug:

1. Check if parent components are subscribing to frequently-changing store state
2. Look for whole object/array destructuring: `const { items } = useStore()`
3. Move to selective subscriptions: `const count = useStore(s => s.items.length)`
4. Add React DevTools Profiler to identify unnecessary re-renders

